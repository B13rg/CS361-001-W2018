\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\graphicspath{ {./} }


\title{Talkatiel FIS}
\author{Brendan Byers, Ryan Sisco, Iliana J, Aidan Grimshaw, Yufei Zeng}
\date{\today}

\begin{document}
\begin{center}
      \Large\textbf{Talkatiel First Implementation of System}\\
      \large\textit{Brendan Byers, Ryan Sisco, Iliana J, Aidan Grimshaw, Yufei Zeng}\\
      \large{byersbr, siscor, javieri, grimshaa, zengyu}\\
   \end{center}

\tableofcontents
\section{Product Release}
   \subsection{Server Side Implementation}
   Currently the server code can be downloaded and run locally.  By cloning the repository located at\begin{verbatim} https://github.com/B13rg/Talkatiel_API.git \end{verbatim}one can run the server.  There is also extensive documentation detailing all the steps that need to be taken to run the server.  There is also a SQL script that will create a database when run.  This can be used to create a database for use on a different engine.  Currently it is configured to run on the localhost on port 5002.  This can be tested to navigating to \begin{verbatim}127.0.0.1:5002/Posts/New \end{verbatim}where you can see the raw Json output of a post.  In the repository there is also an sqlite database that is run alongside the python code.  This will connect with the python to respond to different sql queries.  It is fully functioning, and the only thing left to do is test it, and find a permanent URL.

   \subsection{Client-Side Implementation}
\section{User Story}
      \subsection{Add a post}
      The server-side group worked on adding this ability to the api.  Currently a user is able to POST a json string to the server.  The server takes the json and decodes a post object out of it.  Then the post is passed into the database to be retrieved later.  Implementation of this took 2 hours.  Currently we still need to test the implementation with more extensive unit tests.
      \subsection{Add a Comment}
      The server side group worked on adding this ability to the api.  Currently a user is able to POST a json string to the server.  The server takes the json and decodes a comment object out of it.  Then the post is passed into the database to be retrieved later.  Implementation of this took 1 hour.  It was extremely similar to adding a post.  Currently we still need to test the implementation with more extensive unit tests.
      \subsection{Like/Dislike}
      The server-side group implemented a way to like and dislike posts.  It is done by throwing a 1 or a 0 to the URL of the post.  This will look like this:\begin{verbatim} https://Talkatiel.com/Posts/<int:postID>/<int:voteType> .\end{verbatim}  The server decodes the url and applies the proper vote to the given post.  Implementation took around 3 hours.  Currently there needs to be more testing done.
      \subsection{Report}
      Server group implemented this through the API.  In this case, when the server receives a report about a post, the postID reporting userID, and report message content will be added to a special "reports" table in the database that will be able to viewed by admins later. The implementation took around 3 hours.  Only thing left to do is add a way for admins to access the reports in an orderly way.
      \subsection{Delete}
      The server group worked on the server-side implementation of this.  In order to delete a post a URL is GET requested with the postID.  The id is decoded, and the given post is marked as not visible.  When posts are retrieved from the database for users, the deleted posts are ignored.  The work on this took 2 hours.  It was closely tied to the refresh function.  Currently we need to implement some form of authentication so only requests with the correct key can delete a post.
      \subsection{Refresh}
      The server group worked on this.  In order to refresh and retrieve new posts on the device, one of 3 URLs are sent GET requests.  The URL's determine the type of sort the post are in when returned.  When retrieving posts for the user, the server first checks it's cache.  The posts for any given category are only calculated once every two minutes.  Each time it fetches it will store what it returns in the cache.  This is so we don't overload the database with too many requests.  The only exception in when fetching "New" posts. There is no caching done for fetching them because there’s no calculating to be done.  Currently the API is functional.  Implementation of this portion took 6 hours.  The only thing left is testing.
      \subsection{Sort}
      The server side implemented the different types of sorting.  The posts are fetched from the database based on post date.  When fetching "Best" or "Top", the order of posts must be calculated.  For the "Top" category, the best posts of the last 24 hours are at the top.  They are ranked based on upvotes minus downvotes.  They are only considered if they're marked as visible.  This calculation takes place every 2 minutes due to the use of a cache.  For fetching "Best", the post order is calculated every 2 minutes thanks to the cache.  This cuts down on how many requests we hit the database with.  The calculation factors in post time and number of upvotes and downvotes.  This is a potentially expensive calculation given post activity, so the use of the cache was really important for this set.  The total time for implementation took around 7 hours.  The only thing left is to test the server side of things.
      \subsection{View Newly Created Post}
      Server side worked on this.  Because of how sorting by new is implemented, a user is able to see their posts immediately.  This is because there is no caching done on that sorting method.  This makes it so the database is queried every time.  If the server load was a lot, it would still be acceptable to cache things for even 5 minutes to lighten the load on the server.
      \subsection{Secure HTTPS Connection}
      In order to get a secure https connection, we need to get a security certificate signed by a certificate authority.  We haven’t chosen where the code will be hosted.  Currently we are considering either trying to use the university services or a third party.  I believe that we may be able to host the API server using virtual environments, which may allow us to run a server on that port.  Time spent was 1 hour.  We still need to finalize design choices to receive the certificate.
      \subsection{Save Website as App on Phone}
      Frontend team worked on this part.  Setting up the temporary server led to many issues. There were many dependencies that needed to be installed, and required a Linux operating system to run. After running Linux, many other programs needed to be installed before development was possible. Running the server required internet connection on both the laptop as well as the mobile device, and they needed to be on the same network. We soon realized that OSU’s network would not allow this, and development had to occur off campus. The first laptop took Aidan nearly 3 days before the server was up and running. The second laptop only took 2 hours. Downloading the dependencies to run the app took nearly 40 minutes. Every new laptop we add will take at least this long to run our app while we develop. It is completed and tested. Once we are satisfied with our mobile app, we will transfer the files to our main server and push an android app to the website for download. The iOS app will need to be approved by Apple before it can be added to the marketplace. The UML diagram was not very useful for this. We did not really understand what we needed or how we could accomplish this. We really needed to dive head-first into it in order to find a solution that worked for us. Planning it out ahead of time required us to be correct the first time.
      \subsection{Responsive Web Page}
      This was worked on by the Frontend team. There were many different dependencies that needed to be understood in order to make the UI. In addition to pulling in different frameworks, the JavaScript needed to be the only styling in the app. There was no CSS involved, and the only interaction with styling is done through JavaScript. Once the base code was written, the other parts could be added and changed later on. Developing the basic UI took nearly 10 hours in total. This involved building the base that we could build off of later on, and setting the correct styling data to be changed when needed. This is still in progress, but has been implemented. The colors, server data, and size still need to be corrected. The reason that we waited until after we built a base was to have flexibility later on if we felt that we needed a change. We did not want to have to scrap all of our code. The UML diagram was very useful in this case. It helped guide the project and understand what needed to be added for the base. Having an outline allowed the JavaScript to be built for the long run, and it will be able to support the app very well.

\section{Tests}

So far we have created test that test functionality of the server and funcitonality between the server and client.  We have tests that look at if the server is reachable, if the server is using SSL, and tests that look at the different GET and POST requests that can be made.  An example test for a user story is our test for the different types of sorts.  The tests make a request to the server for either the Top, New, or Hot lists.  The server will respond with data from the databsase.  The test will pass fail depending on if the server responded without an error.  These tests definitely test specific user stories that we created before.  An example of a unit test that tests something not implimented is the SSL test.  SSL is not implimented when running the server on localhost, so the SSL test will fail when testing against a localhost.  In order to get this to succeed, we would need to impliment a way to enable SSL to the localhost.  We may impliment it in the future, but it is not a high priority because the server is not meant to be hosted locally.

Our different unit tests can be found at \begin{verbatim} https://github.com/B13rg/Talkatiel_API/blob/master/Tests/flaskr_tests.py \end{verbatim}

Client side integration tests can be found in the folder containing this tex file / pdf and can be run with \begin{verbatim} ./integrationTest \end{verbatim}
These tests make sure the client side JavaScript code will be able to correctly interact with the server API that Brenden built. 

\section{Design Changes and Rationale}
\subsection{Server Side Implementation}
For the most part the server group stayed very close to original design.  To design the database, we worked off the UML design diagrams we designed earlier.  This allowed us to see what fields we needed to include for each table.  We added an extra table not originally in the design doc to handle reports.  We found there was no way to keep track of reports server side, so we added a table to handle it.  It keeps track of the user who reported it, the post in question, and the text of the user’s report.  By having its own table, it can also be queried separately instead of having to sort through who knows what.
\subsection{Frontend Implementation}
We have stayed very close to our original design. The changes we have right now are temporary and easy to change. We do not have some things matching such as colors, but we have every correct button and card in position. Styling the rest will be very easy. Our buttons do not currently send data to our actual server. This was done intentionally in order to build the backend and frontend at the same time. We are currently fixing the color scheme as we get closer to connecting our mobile app with the database.
\section{Meeting Report}
\subsection{Schedule for next week}
Monday through Friday we plan on focusing around user interface development. During the weekend we plan on switching the team focus to be more on network infrastructure.
\subsection{Progress made this week}
This week we developed several basic user interface template prototypes, as well as built the infrastructure that will allow us to easily build more user interface elements to mobile in the future.
\subsection{Plans and goals for next week}
Next week we plan to refactor out our user interface code to improve code functionality, modularity and style. We will build on the knowlege that we gained this week to develop full features with robust templating. On the Network infrastructure side, we will start setting up servers for the api and the website/app so that the general public can access it when we are done.
\subsection{Team Member Contributions}
\begin{itemize}
      \item Server Side - API - Brendan Byers
      \item Server Side - Database - Iliana Javier
      \item Server Side - User Story - Brendan Byers and Iliana Javier
      \item Server Side - Design Changes - Brendan Byers and Iliana Javier
      \item Frontend - Mobile App - Ryan Sisco and Aidan Grimshaw and Yufei Zeng
      \item Frontend - Basic UI JavaScript - Aidan Grimshaw
\end{itemize}





\end{document}
